Kind is a programming language similar to Agda. Examples:

# Example types:

type Bool {
  true
  false
}

type Nat {
  zero
  succ (pred: Nat)
}

record Pair (a: Type) (b: Type) {
  fst : a
  snd : b
}

type List (t) {
  nil
  cons (head: t) (tail: List t)
}

record Sigma (a: Type) (f: a -> Type) {
  fst : a
  snd : f fst
}

type Vector <a: Type> ~ (len: Nat) {
  nil : Vector a Nat.zero
  cons (len: Nat) (head: a) (tail: Vector a len) : Vector a (Nat.succ len)
}

type Equal <t> (a: t) ~ (b: t) {
  refl : Equal t a a
}

record V3 {
  x: F60
  y: F60
  z: F60
}

# Example programs:

// Using match
Bool.not (b: Bool) : Bool {
  match Bool b {
    true  => Bool.false
    false => Bool.true
  }
}

// Using equations
Bool.not (b: Bool) : Bool
Bool.not Bool.true  = Bool.false
Bool.not Bool.false = Bool.true

// Using match
Pair.fst <a> <b> (pair: Pair a b) : b {
  match Pair pair {
    new => pair.fst
  }
}

// Using equations
Pair.snd <a> <b> (pair: Pair a b) : b
Pair.snd (Pair.new x y) = y

// Using equations
List.head <a> (xs: List a) : Maybe (List a)
List.head List.nil              = Maybe.none
List.head (List.cons head tail) = Maybe.some head

// Recursion
Nat.add (a: Nat) (b: Nat) : Nat
Nat.add (Nat.succ a) b = Nat.succ (Nat.add a b)
Nat.add Nat.zero     b = b

// Lambdas and polymorphism
List.fold <a> <p> (xs: List a) : p -> (a -> p -> p) -> p
List.fold List.nil              = nil => cons => nil
List.fold (List.cons head tail) = nil => cons => cons head ((List.fold tail) nil cons)

// Dependent types
Sigma.snd <a> <b: a -> Type> (s: Sigma a b) : b (Sigma.fst a b s)
Sigma.snd (Sigma.new x y) = y

// More dependent types
Vector.create <a> (len: Nat) (f: Nat -> a) : Vector a len
Vector.create Nat.zero     f = Vector.nil
Vector.create (Nat.succ p) f = Vector.cons p (f Nat.zero) (Vector.create p (x => f (Nat.succ x)))

// Substitution as a function
Equal.rewrite <t> <a: t> <b: t> (e: Equal t a b) -(p: t -> Type) (x: p a) : p b
Equal.rewrite _ _ _ (Equal.refl _ k) p x = x :: p k

// Just a dot product
V3.dot (a: V3) (b: V3) : F60
V3.dot (V3 ax ay az) (V3 bx by bz) =
  let cx = (* ax bx)
  let cy = (* ay by)
  let cz = (* az bz)
  in (+ cx (+ cy cz))

# Example proofs:

// Proof: a == a + 0
Nat.add.comm.zero (a: Nat) : Equal Nat a (Nat.add a Nat.zero)
// goal: 0 == 0
Nat.add.comm.zero Nat.zero =
  // 0 == 0
  let ret = Equal.refl
  ret
// goal: S a == S (a + 0)
Nat.add.comm.zero (Nat.succ a) =
  // a == a + 0
  let ind = (Nat.add.comm.zero a)
  // S a == S (a + 0)
  let app = Equal.apply (x => Nat.succ x) ind
  app

// Proof: (a + 1) + b = a + (b + 1)
Nat.add.comm.succ (a: Nat) (b: Nat) : Equal Nat (Nat.add a (Nat.succ b)) (Nat.succ (Nat.add a b))
// goal: S b == S b
Nat.add.comm.succ Nat.zero b =
  // S b == S b
  let ret = Equal.refl
  ret
// goal: S (a + S b) == S (S (a + b))
Nat.add.comm.succ (Nat.succ a) b =
  // a + S b == S (a + b)
  let ind = Nat.add.comm.succ a b
  // S (a + S b) == S (S (a + b))
  let app = Equal.apply (x => Nat.succ x) ind
  app

// Proof: a + b == b + a
Nat.add.comm (a: Nat) (b: Nat) : Equal Nat (Nat.add a b) (Nat.add b a)
// goal: b == (b + 0)
Nat.add.comm Nat.zero b =
  // b == (b + 0)
  let aux = Nat.add.comm.zero b
  aux
// goal: S (a + b) == b + (S a)
Nat.add.comm (Nat.succ a) b =
  // a + b == b + a
  let ind = (Nat.add.comm a b)
  // S (a + b) == S (b + a)
  let app = (Equal.apply (x => Nat.succ x) ind)
  // b + (S a) == S (b + a)
  let aux = (Nat.add.comm.succ b a)
  // S (b + a) == b + (S a)
  let mir = (Equal.mirror aux)
  // S (a + b) == S (b + a)
  let ret = (Equal.chain app mir)
  ret

// Proof: (S a) != 0
Nat.succ_not_zero (a: Nat) (e: Equal Nat (Nat.succ a) Nat.zero) : Empty
Nat.succ_not_zero a e =
  let app = Equal.apply (x => Nat.is_zero x) e // false == true
  let emp = Bool.false_not_true app // empty
  emp

In Kind, global definitions start with an uppercase letter and can include
periods. So, for example, 'Equal.apply' and 'Nat.add.comm.succ' are both global
definitions, but 'app' and 'emp' are local definitions. This includes types, so,
for example, 'Equal' and 'Nat' are global definitions. Below is a JSON with all
the global definitions used on 'List.head':

["List.head", "List", "Maybe", "List.nil", "List.cons", "Maybe.none", "Maybe.some"]

Notes:
global functions aren't curried. passing them needs lambdas: '(x => Nat.succ x)'
holes are written as '?hole_name'
{{note}}

Below is an incorrect Kind program:

// Main.kind
{{code}}

Below is the error message. The problematic location is surrounded with {{}}:

{{error}}
