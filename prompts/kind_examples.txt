# Example types:

type Bool {
  true
  false
}

type Nat {
  zero
  succ (pred: Nat)
}

type List (t) {
  nil
  cons (head: t) (tail: List t)
}

record Sigma (a: Type) (f: a -> Type) {
  fst : a
  snd : f fst
}

type Vector <a: Type> ~ (len: Nat) {
  nil : Vector a Nat.zero
  cons (len: Nat) (head: a) (tail: Vector a len) : Vector a (Nat.succ len)
}

type Equal <t> (a: t) ~ (b: t) {
  refl : Equal t a a
}

record V3 {
  x: F60
  y: F60
  z: F60
}

# Example programs:

Bool.not (b: Bool) : Bool
Bool.not Bool.true  = Bool.false
Bool.not Bool.false = Bool.true

List.head <a> (xs: List a) : Maybe (List a)
List.head List.nil              = Maybe.none
List.head (List.cons head tail) = Maybe.some head

Nat.add (a: Nat) (b: Nat) : Nat
Nat.add (Nat.succ a) b = Nat.succ (Nat.add a b)
Nat.add Nat.zero     b = b

List.fold <a> <p> (xs: List a) : p -> (a -> p -> p) -> p
List.fold List.nil              = nil => cons => nil
List.fold (List.cons head tail) = nil => cons => cons head ((List.fold tail) nil cons)

Sigma.snd <a> <b: a -> Type> (s: Sigma a b) : b (Sigma.fst a b s)
Sigma.snd (Sigma.new x y) = y

Vector.create <a> (len: Nat) (f: Nat -> a) : Vector a len
Vector.create Nat.zero     f = Vector.nil
Vector.create (Nat.succ p) f = Vector.cons p (f Nat.zero) (Vector.create p (x => f (Nat.succ x)))

Equal.rewrite <t> <a: t> <b: t> (e: Equal t a b) -(p: t -> Type) (x: p a) : p b
Equal.rewrite _ _ _ (Equal.refl _ k) p x = x :: p k

// note: the let syntax doesn't use "in"
V3.dot (a: V3) (b: V3) : F60
V3.dot (V3 ax ay az) (V3 bx by bz) =
  let cx = (* ax bx)
  let cy = (* ay by)
  let cz = (* az bz)
  (+ cx (+ cy cz))

// note: match expressions are also available
Nat.add (a: Nat) (b: Nat) : Nat {
  match Nat a {
    zero => b
    succ => Nat.succ(Nat.add(a.pred, b))
  }
}

Main : IO Unit {
  do IO {
    ask name = IO.prompt "what is your name?"
    IO.print (String.join "" ["Hello, " name "!"])
  }
}

# Example proofs:

// Proof: a == a + 0
Nat.add.comm.zero (a: Nat) : Equal Nat a (Nat.add a Nat.zero)
// goal: 0 == 0
Nat.add.comm.zero Nat.zero =
  // 0 == 0
  let ret = Equal.refl
  ret
// goal: S a == S (a + 0)
Nat.add.comm.zero (Nat.succ a) =
  // a == a + 0
  let ind = (Nat.add.comm.zero a)
  // S a == S (a + 0)
  let app = Equal.apply (x => Nat.succ x) ind
  app

// Proof: (a + 1) + b = a + (b + 1)
Nat.add.comm.succ (a: Nat) (b: Nat) : Equal Nat (Nat.add a (Nat.succ b)) (Nat.succ (Nat.add a b))
// goal: S b == S b
Nat.add.comm.succ Nat.zero b =
  // S b == S b
  let ret = Equal.refl
  ret
// goal: S (a + S b) == S (S (a + b))
Nat.add.comm.succ (Nat.succ a) b =
  // a + S b == S (a + b)
  let ind = Nat.add.comm.succ a b
  // S (a + S b) == S (S (a + b))
  let app = Equal.apply (x => Nat.succ x) ind
  app

// Proof: (S a) != 0
Nat.succ_not_zero (a: Nat) (e: Equal Nat (Nat.succ a) Nat.zero) : Empty
Nat.succ_not_zero a e =
  let app = Equal.apply (x => Nat.is_zero x) e // false == true
  let emp = Bool.false_not_true app // empty
  emp

// In Kind jargon, a "base file" has just a type, one equation and a ?hole:
Main (a: Nat) (b: Bool) : Equal Nat (Nat.is_positive (Nat.succ a)) Bool.true
Main a b = ?hole
